\section{Minimize Switches in Paths}

The goal of this section is to provide a greedy algorithm able to compute an optimal affectation $\affect$ of a given path $\path$. The obtained result, will then be extended to general graphs using the matrix technique proposed in \cref{sec:algo_matrix} or the MDD strategy of \cref{sec:algo_mdd}.
% TODO : give a name to the matrix

\subsection{Procedure}
\label{sec:path_proc}
This problem can be solved through a greedy strategy: taking a path $\path$ and a coloring function $\colf$, we delay a color switch as much as possible. Tha algorithm is decomposed in two main parts where the first one affect each arc $\e_i$ to a subset of colors of $\colf(\e_i)$ and a second one which make a unique affectation for each arc.

\paragraph{Procedure part 1.}
We start from the colors associated to the first arc and we take the colors of the second arc in order to make the intersection of them. We repeat this operation for all the following arcs until the intersection returns a non-empty set or we do not reach the end of the path. At the $i^{th}$ arc, if the intersection set is empty, we make a color switch. Then we repeat the same procedure from this arc starting with a set of colors equal to $\colf(\e_i)$. This procedure returns for each arc a subset of its associated colors.

\paragraph{Procedure part 2.}
We have to make a unique affectation, this is possible by reading the list of set returned by the previous part of the algorithm. For the last arc we take one among all the possible colors. For the next subset of colors related to the before-last arc, we take the same color of the last arc if present, otherwise a random color from its set. We repeat this operation until reaching the first arc of the path.

An implementation of this procedure can be found in \cref{algo:minpath}.


\begin{proof}[Proof (First part of the procedure)]
  Let $\affect_\C = \row{\C}{\len}$ be a solution returned by the first part of our algorithm, we prove by induction on the length of the path that $\affect_\C$ minimizes the number of color switches. After this first proof, we will show that the number of color switches returned by the second part of the algorithm is the same as the one returned by the first part. \\
  By definition of the weight function, if $\len = 1$ we have $\weight(\affect_\C) = 0$ which is the optimal cost.\\
  Let's suppose that $\affect_\C$ is an optimal solution for every path of length at least $\len$. We want to prove that the the new affectation $\affect_\C'$ returned by the algorithm for a path of length $\len+1$ is still optimal. We have to analyze two main situations:

  \begin{itemize}
    \item if $\colf(\e_k) \cap \colf(\e_{k+1}) = \varnothing$ then, for any color $\c_i$ chosen from $\colf(\e_{k+1})$ $\weight(\affect_\C') = \weight(\affect_\C) + 1$, \ie\ a color switch is forced.
    \item otherwise, if $\colf(\e_k) \cap \colf(\e_{k+1}) \neq \varnothing$ we have two sub-cases to treat:
          \begin{itemize}

            \item if it exist a subset of colors $\C_{k+1} \subseteq \colf(\e_{\k+1})$ which is included in $\C_k$, \ie\ there exists at least a color in $\colf(\e_{\k+1})$, allowing us to have $\weight(\affect_\C') = \weight(\affect_\C)$.

            \item this final case is the most interesting to treat because we have $\C_{k} \cap \colf(\e_{\k+1}) = \varnothing$ but of the other hand we have $\colf(\e_{k}) \cap \colf(\e_{\k+1}) \neq \varnothing$. It means that we have done a particular choice of colors associated to the arc $\e_\k$ causing a color switch ($\weight(\affect_\C') = \weight(\affect_\C) + 1$) even if it would have been possible to affect $\e_k$ to the same color of its following arc.\\
                  Let's suppose, by means of contradiction, that it exists a better affectation of subsets for the subpath $\row{\e}{\k + 1}$. Without loss of generality, let's suppose that the intersection of the first $\colf(\e_i), 0 \leqslant i \leqslant k$ is not empty, \ie\ there exists a color which is shared by all the $\e_i$ first arcs. The cost of the this subpath is $0$ since all edges can have the same color. If we want to add the new edge $\e{\k + 1}$ to the path without increasing the number of color switch we need that there exists at least a colors in $\colf(\e{\k + 1})$ which is common to all the $\colf(\e_i), 0 \leqslant i \leqslant k$ first edges. However, this is not possible, otherwise the algorithm would have kept this color as a valid option for all the path. A contradiction.
          \end{itemize}
  \end{itemize}
  We can conclude that the number of color switches returned by the first part of the procedure is minimal.
\end{proof}

\begin{proof}[Proof (Second part of the procedure)]
  In the previous proof, we have shown that the number of color switches return by the first part of the algorithm is minimal. We only have to prove that its second part return exactly the an affectation with the sae number of colors switches to conclude that our algorithm is optimal.\\
  Let $\row{\C}{\len}$ be the subset affectation returned by the previous part of the algorithm. Note that, by construction of the first algorithm, for each set $\C_i$, its successor $\C_{i+1}$ is either a subset of $\C_i$ or $\C_i \cap \C_{i+1} = \varnothing$.
  Starting from the last arc of the path, we can choose an arbitrary color $\c_\len \in \C_\len$ for $\e_\len$. Then for the edge $\e_{\len-1}$, we choose the same color of $\e_len$ if possible and repeat the same procedure until reaching the first edge of the path.\\
  By definition, the number of color switches of the generated path will be qual to the number of two by two different $i, j \in [0..\len]$ such that $\C_i \cap \C_{i+1} = \varnothing$.
\end{proof}

\subsection{Time Complexity}

We can analyze the time complexity of this procedure from the implementation proposed in \cref{algo:minpath}. We have two loops of size $k$ (the length of the path). Inside them we make intersection between sets of at most $s$ colors, then the intersection between two sets of that size will take $\bigo(s)$. Finally, the global time complexity will be $\bigo(2 * k * s) = \bigo(k*s)$.

\subsection{An example run}
\label{sec:path_ex_run}

\input{img/tikz/path_example.tex}

Let's take \cref{fig:path_example}, where $\path = \row{\e}{6}$ and $\colf$ such that
\begin{align*}
  \colf(\path) = ( & \{\eAcols\}, \{\eBcols\},    \\
                   & \{\eCcols\}, \{\eDcols\},    \\
                   & \{\eEcols\}, \{\eFcols\}   )
\end{align*}

Here we give a solution of how the procedure proposed in \cref{sec:path_proc} would solve it. The first procedure will return a list of subsets equal to
\begin{align*}
  \affect' = ( & \{\eAcols\}, \{\colB\},      \\
               & \{\colB\}, \{\colC\},        \\
               & \{\eEcols\}, \{\eFcols\}   )
\end{align*}

Then the second part of the algorithm would return an optimal solution which is, in this case, $\affect = (\colB, \colB, \colB, \colC, \colD, \colD)$, with $\weight(\affect) = 2$.

One can note that there can exist other optimal affectations, from \cref{fig:path_example} we can choose $\affect_2 = (\colA, \colC, \colC, \colC, \colB, \colB)$, but in any case, any other affectations will not be less than  $\weight(H)$.

\subsection{Extension on cycles}

A cycle in a path whose starting node coincide with its last one.
In this situation, the previous algorithm is no more effective, since we need to keep into account the potential color switch between the first and the last arcs.
However, the procedure proposed in \cref{sec:path_proc}, can be easily modified to provide an optimal affectation on cycles.

Let's take the path of \cref{fig:path_example} and imagine that nodes $n_1$ and $n_7$ coincide.
The affectation $\affect$ of \cref{sec:path_ex_run} is no more optimal since $\weight(\affect) = 3$, whereas the cost of the affectation $\affect' = (\colB, \colB, \colB, \colC, \colB, \colB)$ is $2$.

In order to consider this situation, it is important to look at the intersection between the first and the last set of colors returned by the first part of the procedure. In particular, the subset associated to the extrema arcs of the path, will be modified into the intersection of their corresponding sets if non-empty. Finally we can apply second part of the algorithm.

Concretely, take the example in \cref{fig:path_example}, we intersect $\affectf'(\e_1)$ with $\affectf'(\e_7)$. Since this intersection is non-empty, then $\affectf'(\e_1) = \affectf'(\e_7) = \{\colB\}$. And the resulting affectation will be exactly $H'$.

