\section{Minimize colors switches with \mdd s}

In this section we will provide a second approach to the problem using the \textit{MDD} data structure in order to compute the shortest paths of \textit{fixed} length for path starting from a given vertex of the graph.

\subsection{Multi-Valued Decision Diagram}

A \textit{Multi-Valued Decision Diagram (MDD)}\cite{regin} is a generalization of a \textit{Binary Decision Diagram}. It is represented as a directed acyclic graph whose nodes and arcs are called respectively states and transitions. \mdd s are often used to solve constraint satisfaction problems where each layer of the \mdd\ represents a variable of the problem and the number of transitions exiting from a state is upper bounded by the cardinal of the domain of the considered variable.

Even if the number of states may grow exponentially wrt the number of states, if well encoded the problem can be solved with an \mdd\ whose size grows polynomially wrt its input. A well known example of this, is the representation of the language $\mathcal{L}$ accepting binary words with \textit{fixed} length $k$ having a $1$ in the $n$-th last position (an example is provided at \cref{sec:mdd_example}).

\subsection{The \mdd\ strategy}
\label{sec:algo_mdd}
The problem of minimizing the number of color switches in a colored graph can be solved with an \mdd. This strategy is less generic then the matrix method: with the \FW\ matrix approach we compute the shortest paths from all the nodes of the graph, however the \mdd\ should have a root and therefore this strategy will find all the shortest paths of \textit{fixed} number of edges from a chosen node.

\begin{equation}
  \label{eq:record}
  \stateType{\mddState{\text{String}}{\text{Int}}{\text{Set of Colors}}}
\end{equation}

The states of the \mdd\ will be represented by the record depicted in \cref{eq:record} and the root of the \mdd\ will have $\mddState{\C}{0}{n}$ where $n$ is the name of the starting node of the paths. The $\C$ is the set containing all the colors of the problem.

Let $\mddRoot$ be the node chosen for the root of the \mdd, at each iteration $i$ a new layer is added to the \mdd. The $i^{th}$ layer represents the set of shortest paths of length $i$ rooted in $\mddRoot$.

The algorithm which builds the \mdd\ works as follow: for every state $\currState$ with name $\currStateName$ of the current layer and for every successor $\nextStateName$ of $\currStateName$ in $\graph$, let $\mathcal{S} = \colf(\currStateName, \nextStateName) \cap \currState\text{.colors}$. Let $\layer$ be the new layer to build, if $\mathcal{S}$ is non-empty we add to $\layer$ the state

$$\nextState = \mddState{\nextStateName}{\currState\text{.cost}}{\mathcal{S}}$$

otherwise the new state

$$\nextState = \mddState{\nextStateName}{\currState\text{.cost} + 1}{\colf(\currStateName, \nextStateName)}$$

is added\footnote{Note that $\currStateName$ and $\nextStateName$ are two nodes belonging to the graph $\graph$.}.

\paragraph{\mdd\ reduction} Let $\layer$ be the current layer of an \mdd, to avoid the exponential growth of the search tree, an \adhoc\ strategy is applied in order to either ignore dominated states or to merge two \compatibleState\ states. A state $s_1$ is dominated by $s_2$ if they have same \textit{name} and the cost of $s_1$ is smaller than the cost of $s_2$, the dominated states are removed from $\layer$. Two states $s_1$ and $s_2$ are \compatibleState\ if they share the same \textit{name} and the same \textit{cost}. In this case, $s_1$ and $s_2$ are removed from $\layer$ and a third state $s_3 = \mddState{s_1\text{.name}}{s_1.\text{cost}}{s_1\text{.colors} \cup s_2\text{.colors}}$ is added to $\layer$.\\
Finally, the application of the domination and the \compatibleState\ laws ensures that the \mdd\ to only have layers with a size upper-bounded by $|\vset|$.

\begin{proof}[\normalfont\textbf{Proof sketch of the algorithm}]
  For each new-created state, we set its color to the subset of the colors in common with its father. This is equivalent to the \textit{Part A} of the procedure depicted in \cref{sec:path_proc}. We only have to show that the \mdd\ reduction is valid for two states $s_1$ and $s_2$.
  \begin{description}
    \item[Case 1:] $s_1$ dominates $s_2$. In this case, the algorithm is going to remove the state $s_2$, it means that, starting from the root $\mddRoot$, we have found two different paths going to the node $s_1\textit{.name}$ (that is the same of $s_2\text{.name}$) but the path going to $s_2$ is more expensive than the path $s_1$. We can therefore ignore $s_2$ from the current layer.
    \item[Case 2:] $s_1$ and $s_2$ are \compatibleState. In this situation we see that we build a new state $s_3$ having the same \textit{name} and \textit{cost} of $s_1$ (that are the same of $s_2$), but whose colors are the union of the colors of $s_1$ and $s_2$. This union is motivate by the fact that we are saying \change{Continue this proof !}
  \end{description}
  We can conclude that the reduction phase is valid. In the end we can all the minimal-cost paths from the root $\mddRoot$ of the \mdd\ by applying the \textit{part B} of the procedure of \cref{sec:path_proc}.
\end{proof}

\paragraph{Time complexity of this procedure} Let $\vcard$ be the cardinal of $\vset$ and $\len$ be the length of the path to build, thanks to the application of the \mdd\ reduction, we can determined that the overall time complexity is $\bigo(\len \cdot \vcard^2 \cdot \mid \C \mid)$ since at each layer we have at most $\vcard$ states and for each state we should visit at most $\vcard$ successors and for each new-created state, we have to perform an intersection between the colors of each state. Given that $\len$ is a fixed parameter, the complexity can be simplified to $\bigo(n^2 \times \mid \C \mid)$.

\subsection{An example run}

\subsection{The all different constraint}

% TODO

The all different constraint (\alldiff) is a very used constraint in constraint programming (CP). The goal of this constraint is to assign each considered variable to a value of its domain such that there does not exist two variables with same assignment. Even if \alldiff\ is simple to implement sometime it can considerably increase the time complexity of the problem we are dealing with.

Let's take the alphabet $\mathcal{A} = \{a \dots z\}$ and let $\mathcal{L}$ be the set of words of length $3$. The \mdd\ representing all the words of the problem will have $4$ states (the root plus one state per letter in the word). On the other hand, if we add the \alldiff\ constraint on the letters of the words, the corresponding \mdd\ will have $\mid \mathcal{A} \mid \times (\mid \mathcal{A} \mid - 1) \times (\mid \mathcal{A} \mid - 2) + 1$ states. This exponential growth is justified by the inability to efficiently apply the reduction operation on the layer of the \mdd\: in every layer, each state of the \mdd\ has the particular role to ``memorize'' the letters stored previously in order to avoid any possible repetition.

\subsection{Find simple paths}

A variation of the color-switching problem of the graph is the application of the \alldiff\ constraint on the nodes of the graph. The goal of this section is to adapt the \mdd\ algorithm provided in \cref{sec:algo_mdd} in order to apply the \alldiff\ constraint. A path now will be valid only if it is ``simple'' that is we can't pass two times or more on any already visited node.

The main modification we must apply to the previous algorithm is to slightly modify the information stored in the states of the \mdd: a state must remember the sequence of nodes visited to join it from the root. The new state will be represented by the record in \cref{eq:record2}

\begin{equation}
  \label{eq:record2}
  \stateType{\mddStateDiff{\text{String}}{\text{Int}}{\text{Set of Colors}}{\text{Set of Nodes}}}
\end{equation}

The first part of the algorithm of \cref{sec:algo_mdd} remains valid: when we add a new layer $\mathcal{L}$, we loop through every state $\currState$ of the previous layer and, for every successor $\nextStateName$ of $\currStateName = \currState\text{.name}$, we build the new state $\nextState$. The only new operation to do in this variation, is to update the \textit{parents} field of $\nextState$ which will be set to $\currState\text{.parent } \cup \{\currStateName\}$\footnote{Note that the \textit{parents} field of the root is the empty set.}.

Furthermore, the \mdd\ reduction should be modified to keep into account the \textit{fathers} of each state. Let $s_1$, $s_2$ be two states belonging to the same layer of the \mdd\; $s_1$ dominates $s_2$ if they have same \textit{name}, same \textit{parents}\footnote{The symmetrical difference between the set of parents of $s_1$ and the set of parents of $s_2$ is empty} and the \textit{cost} of $s_1$ is smaller than the \textit{cost} of $s_2$, moreover $s_1$ and $s_2$ are \compatibleState\ if the have same \textit{name, parents} and \textit{cost}.

\paragraph{Time complexity} The \alldiff\ constraint forces to compute paths of length at most $\mid \vset \mid$, since a longer path should contain repetitions of nodes. A path of length $\mid \vset \mid$ passing exactly one time per node is called an \textit{Hamiltonian Path} and compute such a path is a \textit{NP-Complete} problem.

% \subsection{The NValue constraint}
