\section{Minimize colors switches with MDDs}

\subsection{Multi-Valued Decision Diagram}

A \textit{Multi-Valued Decision Diagram (MDD)}\cite{regin} is a generalization of a \textit{Binary Decision Diagram}. It is represented as a directed acyclic graph whose nodes and arcs are called respectively states and transitions. \mdd s are often used to solve constraint satisfaction problems where each layer of the \mdd\ represents a variable of the problem and the number of transitions exiting from a state is  by the  by the cardinal of the domain of the considered variable.

Even if the number of states may grow exponentially wrt the number of states, if well coded the problem can be solved with an \mdd\ whose size grows polynomially wrt its input. A well known example of this, is the representation of the language $\mathcal{L}$ accepting binary words with fixed length $k$ having a $1$ in the $n$-th last position (an example is provided at \cref{sec:mdd_example}).

\subsection{MDD strategy}
\label{sec:algo_mdd}
The problem of minimizing the number of color switches in a colored graph can be solved with an \mdd. This strategy is less generic then the matrix method: with the \FW\ matrix approach we find shortest paths starting indistinctly from any node of the graph, however the \mdd\ should have a root and therefore this strategy will find all the shortest paths of fixed number of edges from a chosen node.

\begin{equation}
  \label{eq:record}
  \text{state} = \{\text{name: String; cost: Int; colors: Set of Colors}\}
\end{equation}

The states of the \mdd\ will be represented by the record depicted in \cref{eq:record} and the root will be $\{\text{colors: Set.Full, cost:} 0\}$, where \textit{name} is the name given to the current node in the graph and \textit{Set.Full} is the set containing all the colors returned by $\colf$.

Let $r$ the node chosen for the root of the \mdd, at the $i^{th}$ iteration a new layer is added to the \mdd, in order to represent the set of shortest paths of length $i$ rooted in $s$.

The algorithm aiming to build the \mdd\ works as follow: for every state $s$ of the current state and for every successor $n$ of $s$ in $G$, let $\mathcal{S} = \colf(s, n) \cap \text{s.colors}$. Let $\mathcal{L}$ be the new layer to build, if $\mathcal{S}$ is non-empty we add to $\mathcal{L}$ the record
$$\{\text{name: n; cost: s.cost; colors: } \mathcal{S}\}$$ otherwise the record
$$\{\text{name : n; cost: s.cost} + 1 \text{; colors: \colf(s.name, n)}\}$$ is added.

To avoid the exponential growth of the search tree, an \adhoc\ strategy is applied in order to either ignore all dominated states or to merge two compatible states. A state $s_1$ is dominated by $s_2$ if they have same \textit{name} and $s_1.\text{cost} < s_2.\text{cost}$, every dominated state is removed from $\mathcal{L}$. Two states $s_1$ and $s_2$ are compatible (and removed from $\mathcal{L}$) if they share the same \textit{name} and the same \textit{cost}. In this case a third state $s_3 = \{\text{name: } s_1.\text{name; cost: } s_1.\text{cost; colors: } s_1.\text{colors} \cup s_2.\text{colors}\}$ is built and added in $\mathcal{L}$.

The application of this reduction the \mdd\ ensures us to only have can grow of at most $|\vset|$ at each level.

Let $n$ be the cardinal of $\vset$ and $l$ be the length of the path to build, This last remark can be exploited to give an information about the complexity of the algorithm which is bounded by $\bigo(l \cdot n^2)$ since at each layer we have at most $n$ states and for each state we should visit at most $n$ successor states. Moreover, given that $l$ is a fixed parameter, the complexity can be simplified to $\bigo(n^2)$.


\change{Add proof ?}

\subsection{The all different constraint}

The all different constraint (\alldiff) is a very used constraint in CP whose goal is to affect each variable to a value of its domain such that there does not exist to variables with same affectation. This constraint is very simple to implement, but sometimes, it can complexify the problem we are dealing with.

Let's take the alphabet $\mathcal{A} = \{a \dots z\}$ an let $\mathcal{L}$ be the set of words of length $3$. The \mdd\ satisfying this problem will have on $4$ states (including the root), whereas the \mdd\ for the same problem with the \alldiff\ constraint on the letter of the words will have $\mid \mathcal{A} \mid \times (\mid \mathcal{A} \mid - 1) \times (\mid \mathcal{A} \mid - 2) + 1$ states. This exponential growth is due to the inability of reducing the with of the layers since each state of the \mdd\ has the particular role to ``memorize'' the letters stored previously in order to avoid any possible repetition.

\subsection{Find simple paths}

In this section we are going to adapt the \mdd\ algorithm provided in \cref{sec:algo_mdd} in order to apply the \alldiff\ constraint on the nodes of the paths. A path now will be valid only if it is ``simple'' that is we can't pass two times or more on any already visited node of the graph.

In order to solve this newly added constraint in the problem, we have to slightly modify the information stored in the states of the \mdd\ in order to remember from which nodes we are coming from. Therefore, a state will now be represented by the record in \cref{eq:record2}

\begin{equation}
  \label{eq:record2}
  \text{state} = \{\text{name: String; cost: Int; colors: Set of Colors; parents: Set of Nodes}\}
\end{equation}

The first part of the algorithm of \cref{sec:algo_mdd} remains valid: when we add a new layer $\mathcal{L}$, we loop through every state $s$ of the previous layer and for every successor $n$ of $s$ we build the new state. The only new operation to do in this situation, is to update the \textit{parent} field of $n$ which will be $\{\text{s.parent } \cup \text{ s.name}\}$\footnote{Note that the \textit{parents} field of the root is the empty set.}.

The important modification to focus on, is the \mdd\ reduction. Currently, a state $s_1$ is dominated by a state $s_2$ if they have same \textit{name}, same \textit{parents} (\ie\ $s_1.\text{parents} \Delta s_2.\text{parents} = \varnothing$) and the \textit{cost} of $s_2$ is less than the \textit{cost} of $s_1$, and two states are compatible if the have same \textit{name, parents} and \textit{cost}. This two conditions are useful respectively to remove dominated states and merge compatible states.

We can finally see that the introduction of the \alldiff\ constraint causes a complexity blow up from a polynomial to an exponential one. In fact, the size of the layers in the \mdd\ can grow of at most $|\vset|$ at each level.


% \subsection{The NValue constraint}
